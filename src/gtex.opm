\_def\GTeX{\leavevmode\hbox{\lower.5ex\hbox{G}\kern-.18em\TeX}}

\_codedecl \guix {An interface to include results of Guix evaluations <0.3>}

\_namespace{gtex}

   \_doc
   \sec Primitives
   \_cod

\_def\.gscriptpath{\_jobname.scm}
\_def\.grespath{\_jobname.inp}
\_isfile\.gscriptpath\_iffalse\_opwarning{
The auxiliary file `\.gscriptpath` will be created,
you can use `gtex \.gscriptpath` to create the file
`\.grespath` that will contain this document's dependencies.
}\_fi

\_directlua{require('gtex.lua')}

  \_doc
The first \GTeX{} primitive is \`\guix`,
it takes an arbitrary identifier
(only limitation is it must not contain a `:`),
and a Guix expression.
It writes these to an auxiliary file named \`\jobname``.scm`, so that the results
of said expression can later be retreived given the chosen identifier.
\_cod

\_def\.guix#1#2{\_directlua{guix([[#1]], [[#2]])}}

  \_doc
\GTeX{} opens a file called \`\jobname``.inp` if it exists.
This file is generated by the `gtex` script and
contains pairs of identifiers and their resulting built paths,
that Guix produced.
These are defined as macros
named `\csname guix:identifier\endcsname` containing the path,
when you load-in \GTeX{} and can be accessed by passing the identifier to \`\guixref`.
\_cod

\_directlua{load_guixrefs([[\.grespath]])}
\_def\.guixref#1{\_directlua{guixref([[#1]])}}

\_nspublic \guix \guixref ;

  \_doc
\`\insremotefile` takes an identifier, uri and a hash,
and causes Guix to download the file as a result.
\`\remotefile` doesn't take an identifier and only
creates the guix expression without registering it with \GTeX.
You can override the method used to fetch the resource using
\`\remotemethod`.
The uri is implicitly wrapped in quotes for convenience,
to prevent this you can rebind \`\uriwrapper` for example to \`\useit`.
\_cod

\_newpublic\_def\remotemethod{(@ (guix download) url-fetch)}
\_newpublic\_def\uriwrapper#1{"#1"}

\_def\.remotefile#1#2{
(let ((h ((@ (guix base64) base64-decode) "#2")))
  ((@ (guix download) origin)
    (uri \uriwrapper{#1})
    (method \remotemethod)
    (sha256 h)))
}
\_def\.insremotefile#1#2#3{\.guix{#1}{\.remotefile{#2}{#3}}}

\_nspublic \remotefile \insremotefile ;

\_newpublic\_def\insapdownscale{0.76}

  \_doc
  \sec Images
  \`\insappic` is a convenience function to insert
  an image at a size close to \`\vsize` by \`\hsize`
  without breaking its aspect ratio.
  \_cod

\_def\.insappic#1{%
  \_vfil%
  \_hbox to \_hsize{%
    \_hfil%
    \_def\.pic{\.maybeinspic{\.guixref{#1}}}
    \_setbox0=\_vbox{\.pic}
    \picw=\dimexpr\expr{math.min(\bp{\hsize}/\bp{\wd0}, 
                                 \bp{\vsize}/\bp{\ht0})
                                 * \insapdownscale
                                 * \bp{\wd0}}pt\relax
    \.pic
    \_hfil%
  }%
  \_vfil
}

\_nspublic \insappic ;

  \_doc
  \GTeX{} has to deal with many file inclusions from paths that may not exist yet,
  \`\maybeinspic` is \`\inspic` but only inserts if the image exists.
  \_cod

\_def\.maybeinspic#1{%
  \_isfile{#1}%
  \_iftrue\_inspic{#1}%
  \_else#1:??%
  \_fi%
}

\_nspublic \maybeinspic ;

  \_doc
  \`\gexpcatcodes` is a set of catcodes to make writing
  GExp heavy Scheme code more convenient under \TeX.
  \_cod

\_def\.gexpcatcodes{
        \_catcode`\#=12
        \_catcode`\$=12
        \_catcode`\;=6
}

\_nspublic \gexpcatcodes ;

  \_doc
  The r in \`\rinspic` stands for remote,
  it inserts an image from a remote location,
  takes the same arguments as \`\remotefile`.
  The svg variant passes the remote resource through inkscape,
  to render it.
  \`\svgrender` contains the GExp to render with inkscape,
  you can pass in any file-like object.
  \`\inkscapeactions` if defined are passed to inkscape to be performed
  before the render.
  \_cod

{
\.gexpcatcodes

\_gdef\.svgrender;1{
 (computed-file
   "svg-image.png"
   #~(begin
       (setenv "HOME" (getcwd))
       (system*
        #$(file-append (@ (gnu packages inkscape) inkscape)
                       "/bin/inkscape")
        \isdefined{inkscapeactions}
                \iftrue#«--actions=\inkscapeactions»\fi
        #$;1
        "-o" #$output
        "-w" "1920")))
}
}
%$

\_def\.rinspic#1#2#3{%
  \.insremotefile{#1}{#2}{#3}%
  \.insappic{#1}%
}

\_def\.rinssvg#1#2#3{%
  \.guix{#1}{\.svgrender{\.remotefile{#2}{#3}}}%
  \.insappic{#1}%
}

\_nspublic \rinspic \rinssvg \svgrender ;

  \_doc
  \sec[cmd] Command Line Interpretation
  \_cod

  \_doc
  \`\eval` is what handles most actual external program
  executions, it takes two arguments, the ''command line''
  and a Guix file-like to pose as the source code.
  The result is expected on `stdout`.
  \`\namedeval` takes one extra argument for if you need the
  resulting file to have a specific name.

  The ''command line'' is interpreted in the following way:

  \secc Doesn't contain |

  The first word is the command, taken to be the
  name of a known Guix package.
  The command that will be run is `<pkg-dir>/bin/<pkg-name>`,
  however if the name contains a `/` it will be `<pkg-name>/bin/<your-suffix>` instead.
  So `node` runs the equivalent of `$(guix build node)/bin/node $script` and `coreutils/ls` will run
  `$(guix build coreutils)/bin/ls $script`.
  The given command receives your script as the first argument.
  The rest of the line is passed as is.

  \secc Contains |

  In this case the section up until the first `|` is a list of packages
  to install inside a profile, separated by commas.
  After that any arbitrary shell pipeline may follow,
  and it will be evaluated in the context of a profile containing all of the mentioned packages.
  The first command in the pipeline again receives the script as its first argument.

  i.e. `python, python-scipy, lolcat | python3 | lolcat`

  will run the pipeline `python3 $script | lolcat` %$
  in a context where those 3 packages are present.

  \_cod

\_def\.eval#1#2{((@ (gtex) eval-script) "#1" #2)}
\_def\.namedeval#1#2#3{((@ (gtex) eval-script) "#2" #3 "#1")}

\_nspublic \eval \namedeval ;

\_newcount\.gensym_counter
\_def\.symcr#1{#1\_the\.gensym_counter}
\_long\_def\.gensym#1#2{
        \_incr\.gensym_counter%
        \_def\.sym{\.symcr{#1}}%
        #2%
}

\_edef\.quote{"}
\_def\.maybe_slash{}

  \_doc
  Since Guile uses quotation marks to delimit some parts
  of the build expressions, they might at times need to be escaped.
  \GTeX's hacky solution to this for now,
  are the following macros.
  \`\aqinit` sets the quotation mark as an active
  character that expands to either a lone quote,
  or an escaped quote if \`\autoquote` appears in scope.
  Since \OpTeX-slides delimits each slide,
  there's a shortcut \`\aq` which you can place
  at the top of a slide and all the quotes in that slide
  will be escaped.
  \_cod

\_long\_def\.autoquote{%
  \_def\.maybe_slash{\_bslash}%
}

\_def\.aqinit{\_adef"{\.maybe_slash\.quote}}
\_def\.aq{\.aqinit\.autoquote}

\_nspublic \autoquote \aq \aqinit ;

  \_doc
  The \`\graphviz` environment,
  takes in source in the DOT language,
  and inserts an image of the rendered graph.
  \_cod

\_def\.graphviz#1{%
  \.gensym{graphviz}{%
    \.guix{\.sym}%
    {\.feval{dot.png}{graphviz/dot -Tpng}{%
      \.textfile{dot.dot}{#1}}}

    \.insappic{\.sym}
}}

\_nspublic \graphviz ;

{
\.gexpcatcodes

\_gdef\.textfile;1;2{((@ (guix gexp) mixed-text-file) ";1" #«;2»)}
}

\_nspublic \textfile ;

  \_doc
  \`\showline` takes a line of code and prints that line and its result.
  The interpreter and style of printing is overriden by
  \`\evaluator` and \`\printer` respectively.
  \_cod

\_newpublic\_def\printer#1{(display #1)}
\_newpublic\_def\evaluator{guile}

{
\.gexpcatcodes
\_gdef\.showline;1{%
  \.gensym{showline}{%
        \.guix{\.sym}{%
  (computed-file "\.sym"
    #~(with-output-to-file #$output
        (lambda ()
          (display #«;1»)
          (display " => ")
          (display
            (call-with-input-file
              #$\.eval{\evaluator}{\.textfile{\.sym}{\printer{;1}}}
              (@ (ice-9 textual-ports) get-string-all))))))}%
    \_verbinput (-) \.guixref{\.sym} \_relax %
}}
}

\_nspublic \showline ;

  \_doc
  \`\beggt` and \`\endgt` create an environment
  to run a script.
  \`\beggt` takes two arguments,
  the identifier for the result of the evaluation
  and the \ref[cmd]{command line} that will evaluate the code.
  \GTeX{} then scans until it encounters \`\endgt`.
  \`\.gtexcatcodes` not to be confused with,
  \^`\.gexpcatcodes` are meant to help with writing
  inline, whitespace-sensitive code.
  \_cod

\_def\.gtexcatcodes{%
  \_adef\^^M{\_bslash n}%
  \_catcode` =13%
}

\_def\.beggt#1#2{
  \_bgroup%
  \.gtexcatcodes%
  \.readgt{#1}{#2}%
}

\_def\.readgt#1#2#3\endgt{
  \.gensym{readgt}{%
    \.guix{#1}{\.eval{#2}{\.textfile{\.sym}{#3}}}%
    \_egroup%
  }
}

\_nspublic \beggt ;

\_endnamespace
\_endcode

\_doc
\load[doc]

\tit \GTeX: To interface with the Guix daemon from \OpTeX
\centerline{\it Michal Atlas}

\maketoc

\sec Foreword

\GTeX{} is heavily opinionated,
this might change in the future,
however right now, the target behaviour is to be able to
throw the given macro in the middle of an \OpTeX{} slide
and for it to be readable.

\printdoc gtex.opm

\sec Special Syntax for inline code

In order to aid with writing code samples that
need to be formatted a certain specific way \GTeX,
offers a special syntax.

If a line begins with the `«` character,
the \TeX{} tokenizer will be suspended and
the lines up until one beginning with `»` are
read in by Lua with absolutely no \TeX{} involvement.

For example:

\begtt
​«python/python3
def foo():
  print(2 % 2)

foo()
»
\endtt

This emits a verbatim inclusion
of the original code,
followed by an \`\hline`
and finally a verbatim inclusion of the stdout of the program.
For the interpretation of the first line see \ref[cmd]{Command Line}.

\sec Index
\begmulti 4
  \tt \makeindex      % prints index in three columns
\endmulti

\bye
\_cod

\_endinput

;; Local Variables:
;; mode: TeX
;; End:
